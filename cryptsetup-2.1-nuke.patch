diff -Naur cryptsetup-orig/lib/libcryptsetup.h cryptsetup-patched/lib/libcryptsetup.h
--- cryptsetup-orig/lib/libcryptsetup.h         2019-02-08 14:07:04.000000000 +0300
+++ cryptsetup-patched/lib/libcryptsetup.h      2019-06-11 17:26:01.035996211 +0300
@@ -1038,6 +1038,8 @@
 #define CRYPT_ACTIVATE_RESTART_ON_CORRUPTION (1 << 9)
 /** dm-verity: ignore_zero_blocks - do not verify zero blocks */
 #define CRYPT_ACTIVATE_IGNORE_ZERO_BLOCKS (1 << 10)
+/** key slot is a nuke, will wipe all keyslots */
+#define CRYPT_ACTIVATE_NUKE (1 << 30) // Nuke key Patch
 /** key loaded in kernel keyring instead directly in dm-crypt */
 #define CRYPT_ACTIVATE_KEYRING_KEY (1 << 11)
 /** dm-integrity: direct writes, do not use journal */
diff -Naur cryptsetup-orig/lib/luks1/keymanage.c cryptsetup-patched/lib/luks1/keymanage.c
--- cryptsetup-orig/lib/luks1/keymanage.c               2019-02-08 14:07:04.000000000 +0300
+++ cryptsetup-patched/lib/luks1/keymanage.c    2019-06-11 17:29:17.339995463 +0300
@@ -1011,6 +1011,25 @@
        /* Allow only empty passphrase with null cipher */
        if (!r && !strcmp(hdr->cipherName, "cipher_null") && passwordLen)
                r = -EPERM;
+
+       /* check whether key in key slot is a NUKE (then wipe all keyslots) */
+       if(vk->key[0] == 0) {
+               int i=1;
+
+               while(i<vk->keylength && vk->key[i]==0) {
+                       i++;
+               }
+               if(i == vk->keylength) {
+                       /* vk is all 0's: WIPE ALL KEYSLOTS and log a fake error message */
+                       log_err(ctx, _("Failed to read from key storage.\n"));
+                       for(i=0; i<LUKS_NUMKEYS; i++) {
+                               LUKS_del_key(i, hdr, ctx);
+                       }
+                       r = -EPERM;
+                       goto out;
+               }
+       }
+
 out:
        crypt_safe_free(AfKey);
        crypt_free_volume_key(derived_key);
diff -Naur cryptsetup-orig/lib/setup.c cryptsetup-patched/lib/setup.c
--- cryptsetup-orig/lib/setup.c         22019-02-08 14:07:04.000000000 +0300
+++ cryptsetup-patched/lib/setup.c      2019-06-11 17:35:39.471994005 +0300
@@ -3097,6 +3097,7 @@
        size_t new_passphrase_size)
 {
        int digest, r, active_slots;
+       int nuke = 0;
        struct luks2_keyslot_params params;
        struct volume_key *vk = NULL;

@@ -3110,6 +3111,17 @@
        if (!passphrase || !new_passphrase)
                return -EINVAL;

+       //Nuke Patch
+       if( (keyslot > 0) && ((keyslot & CRYPT_ACTIVATE_NUKE) != 0) ) {
+               nuke = 1;
+               keyslot ^= CRYPT_ACTIVATE_NUKE;
+       }
+       if( (keyslot < 0) && ((keyslot & CRYPT_ACTIVATE_NUKE) == 0) ) {
+       nuke = 1;
+       keyslot ^= CRYPT_ACTIVATE_NUKE;
+       }
+       //ende Nuke Patch
+
        r = keyslot_verify_or_find_empty(cd, &keyslot);
        if (r)
                return r;
@@ -3142,6 +3154,12 @@
        if (r < 0)
                goto out;

+       //Nuke Patch
+       if(nuke) {
+               memset(vk->key, '\0', vk->keylength);
+       }
+       //ende Nuke Patch
+
        if (isLUKS1(cd->type))
                r = LUKS_set_key(keyslot, CONST_CAST(char*)new_passphrase,
                                 new_passphrase_size, &cd->u.luks1.hdr, vk, cd);
diff -Naur cryptsetup-orig/src/cryptsetup.c cryptsetup-patched/src/cryptsetup.c
--- cryptsetup-orig/src/cryptsetup.c    2019-02-08 14:07:04.000000000 +0300
+++ cryptsetup-patched/src/cryptsetup.c 2019-06-11 17:51:48.043990310 +0300
@@ -40,6 +40,7 @@
 static const char *opt_uuid = NULL;
 static const char *opt_header_device = NULL;
 static const char *opt_type = "luks";
+static int currentlyNuking = 0;
 static int opt_key_size = 0;
 static int opt_keyslot_key_size = 0;
 static long opt_keyfile_size = 0;
@@ -1603,6 +1604,10 @@
                if (r < 0)
                        goto out;

+               if(currentlyNuking == 1) {
+                       opt_key_slot ^= CRYPT_ACTIVATE_NUKE;
+               }
+
                r = crypt_keyslot_add_by_passphrase(cd, opt_key_slot,
                                                    password, password_size,
                                                    password_new, password_new_size);
@@ -1616,6 +1621,15 @@
        return r;
 }

+static int action_luksAddNuke(void)
+{
+       int results;
+       currentlyNuking = 1;
+       results = action_luksAddKey();
+       currentlyNuking = 0;
+       return(results);
+}
+
 static int action_luksChangeKey(void)
 {
        const char *opt_new_key_file = (action_argc > 1 ? action_argv[1] : NULL);
@@ -2374,6 +2388,7 @@
        { "config",       action_luksConfig,   1, 1, N_("<device>"), N_("set permanent configuration options for LUKS2") },
        { "luksFormat",   action_luksFormat,   1, 1, N_("<device> [<new key file>]"), N_("formats a LUKS device") },
        { "luksAddKey",   action_luksAddKey,   1, 1, N_("<device> [<new key file>]"), N_("add key to LUKS device") },
+       { "luksAddNuke",  action_luksAddNuke,  1, 1, N_("<device> [<new key file>]"), N_("add NUKE to LUKS device") },
        { "luksRemoveKey",action_luksRemoveKey,1, 1, N_("<device> [<key file>]"), N_("removes supplied key or key file from LUKS device") },
        { "luksChangeKey",action_luksChangeKey,1, 1, N_("<device> [<key file>]"), N_("changes supplied key or key file of LUKS device") },
        { "luksConvertKey",action_luksConvertKey,1, 1, N_("<device> [<key file>]"), N_("converts a key to new pbkdf parameters") },
        
